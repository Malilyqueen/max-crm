// --- Imports uniques (ESM) ---
import express from 'express';
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import dotenv from 'dotenv';
import cors from 'cors';
import { exec } from 'child_process';
import crypto from 'node:crypto'; // <-- AJOUT: import pour HMAC (ESM)

// --- CORRECTIF : .env doit √™tre charg√© AVANT les autres imports ---
dotenv.config();
// --- Fin du correctif ---

// ‚úÖ journal des actions (un seul import !)
import { logTask, readTaskHistory, latest } from './utils/task-log.js';

// ‚úÖ gestion des leads
import { upsertLeads, analyzeLeads, suggestTags } from './utils/leads-store.js';

// (s'il existe chez toi) ton helper historique chat :
import { saveChatHistory, getChatHistory } from './utils/chat-history.js';
import { espo, getMetadata, updateEntity, linkMany, ensureTagId } from './utils/espoClient.js';
import { mapLead } from './utils/lead-mapper.js';
import { say } from './utils/say.js';
import { analyzeCSV, enrichRealCSV } from './utils/analyzeCsv.js';
import { getAllLeads, updateLead } from './utils/espo-api.js';

// --- init dirname/filename (obligatoire avant d'utiliser __dirname)
const __filename = fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);

// --- .env (l'appel .config() est d√©j√† fait en haut) ---

// --- CORRECTIF 2 : Chargement de l'identit√© de l'agent (D√âPLAC√â ICI) ---
const DATA_DIR = path.join(__dirname, 'data');
const AGENT_IDENTITY_PATH = path.join(DATA_DIR, 'agent_identity.json');
let agentIdentity = {};
try {
  if (fs.existsSync(AGENT_IDENTITY_PATH)) {
    const raw = fs.readFileSync(AGENT_IDENTITY_PATH, 'utf8');
    agentIdentity = JSON.parse(raw);
  } else {
    throw new Error('agent_identity.json manquant');
  }
} catch (e) {
  console.error('‚ö†Ô∏è  Impossible de lire data/agent_identity.json ‚Äî v√©rifiez le fichier.', e.message);
  agentIdentity = {}; // ou valeurs par d√©faut minimales si besoin
}
// --- Fin du correctif de d√©placement ---


// --- Logger simple (apr√®s __dirname)
const logFile = path.join(__dirname, 'logs', 'server.log');
function log(...args) {
  const line = `[${new Date().toISOString()}] ${args.join(' ')}\n`;
  console.log(line);
  try {
    fs.mkdirSync(path.dirname(logFile), { recursive: true });
    fs.appendFileSync(logFile, line);
  }
  catch (e) { console.error('Impossible d‚Äô√©crire dans server.log:', e.message); }
}

// --- HOTFIX: task store minimal + logExecution ---
global.logExecution = function (task, level, msg, meta) {
  try {
    task.logs = task.logs || [];
    task.logs.push({ t: Date.now(), level: level || 'info', msg: msg || '', meta: meta || null });
    task.updatedAt = new Date().toISOString();
    if (typeof saveTask === 'function') saveTask(task); // sauvegarde si mini-store pr√©sent
  } catch (_) { /* no-op */ }
};
// --- FIN HOTFIX ---

// Log au d√©marrage (cr√©e logs/server.log m√™me sans appel)
log('BOOT', 'M.A.X. d√©marre sur le port', process.env.PORT || 3005);
console.log('[M.A.X] .env charg√©:', fs.existsSync(path.join(__dirname, '.env')));
console.log('[M.A.X] API_KEY lue:', process.env.ESPO_API_KEY);

// >>> tu peux aussi logger ici
console.log('[M.A.X] ESPO_URL =', process.env.ESPO_URL, ' | API_KEY last4 =', (process.env.ESPO_API_KEY || '').slice(-4));
import analyzeResultRoutes from './routes/analyzeResult.js';
import etqActionsRoutes from './routes/etq_actions.js';
const app = express();
app.use(cors({ origin:'*' }));
app.use(express.json({ limit:'5mb' })); // <-- Votre plan le demande, il est bien l√†
app.use(express.urlencoded({ extended:true }));

// --- AJOUT (depuis votre plan) : Route de test Echo ---
app.post('/api/__echo', (req, res) => {
  console.log('[ECHO] Body re√ßu:', req.body);
  res.json({ ok: true, body: req.body });
});
// --- Fin de l'ajout ---

// POST /api/tags/apply-suggested  -> applique toutes les suggestions courantes
app.post('/api/tags/apply-suggested', express.json(), async (req, res) => {
  try {
    const items = typeof suggestTags === 'function' ? suggestTags() : [];
    let totalApplied = 0;
    for (const s of items) {
      if (!s.applyTo?.length) continue;
      // TODO: ici, brancher EspoCRM si n√©cessaire. Pour l‚Äôinstant, on ‚Äúsimule‚Äù local.
      // await espoApplyTagToLeads(s.key, s.applyTo);

      totalApplied += s.applyTo.length;
      if (typeof logTask === 'function') {
        logTask({
          action: 'Ajout Tag',
          entity: 'Lead',
          details: { tag: s.key, count: s.applyTo.length, leadIds: s.applyTo, rule: s.rule },
        });
      }
    }

    const reply = `T√¢ches ${items.length} tags propos√©s trait√©s. ${totalApplied} affectations au total.`;
    // --- CORRECTIF 4: "saveToHistory" -> "saveChatHistory"
    saveChatHistory({ role: 'assistant', message: reply });
    res.json({ ok: true, appliedTags: items.map(i => i.key), totalApplied, reply });
  } catch (e) {
    console.error('apply-suggested error:', e);
    res.status(500).json({ ok: false, error: String(e) });
  }
});

// POST /api/tags/apply  -> { tag: string, leadIds: string[] }
app.post('/api/tags/apply', express.json(), async (req, res) => {
  try {
    const { tag, leadIds } = req.body || {};
    if (!tag || !Array.isArray(leadIds) || !leadIds.length) {
      return res.status(400).json({ ok: false, error: 'tag + leadIds[] required' });
    }
    // TODO: brancher EspoCRM ici si tu veux l‚Äôeffet c√¥t√© CRM.
    // await espoApplyTagToLeads(tag, leadIds);

    if (typeof logTask === 'function') {
      logTask({ action: 'Ajout Tag', entity: 'Lead', details: { tag, count: leadIds.length, leadIds } });
    }
    const reply = `‚úÖ Tag "${tag}" appliqu√© √† ${leadIds.length} leads.`;
    // --- CORRECTIF 4: "saveToHistory" -> "saveChatHistory"
    saveChatHistory({ role: 'assistant', message: reply });
    res.json({ ok: true, applied: leadIds.length, reply });
  } catch (e) {
    res.status(500).json({ ok: false, error: String(e) });
  }
});

// === CSV helpers & normalisation texte ===
const stripBOM = s => s?.replace(/^\uFEFF/, '') ?? '';
const pickSep = s => (s.includes(';') ? ';' : ',');

function csvToRows(csvTextRaw) {
  const csvText = stripBOM(String(csvTextRaw));
  const lines = csvText.split(/\r?\n/).filter(Boolean);
  if (lines.length === 0) return { header: [], rows: [], sep: ',' };
  const sep = pickSep(lines[0]);
  const header = lines[0].split(sep).map(h => h.trim());
  const rows = lines.slice(1)
    .filter(Boolean)
    .map(line => line.split(sep).map(c => c.trim()));
  return { header, rows, sep };
}

function rowToObj(header, arr) {
  const o = {};
  header.forEach((k, i) => o[k] = (arr[i] ?? '').trim());
  return o;
}

function normalizeToText(x) {
  if (x == null) return "";
  if (typeof x === "string") return x;
  if (Buffer.isBuffer(x)) return x.toString("utf8");
  if (Array.isArray(x)) return x.join("\n");
  if (typeof x === "object") {
    if ("content" in x) return normalizeToText(x.content);
    if ("data" in x && Array.isArray(x.data)) {
      try { return Buffer.from(x.data).toString("utf8"); } catch {}
    }
    try { return JSON.stringify(x); } catch { return String(x); }
  }
  return String(x);
}

// parseur CSV simple
function parseCsvLoose(csvText) {
  const lines = csvText.split(/\r?\n/).filter(Boolean);
  if (!lines.length) return [];
  const header = lines.shift().split(/[,;|\t]/).map(h => h.trim());
  return lines.map(line => {
    const cols = line.split(/[,;|\t]/).map(c => c.trim());
    const obj = {};
    header.forEach((h, i) => obj[h] = cols[i] || '');
    return obj;
  });
}

// POST /api/ask-task-with-file  -> lit CSV/JSON, upsert, analyse, propose tags, log + chat reply
// POST /api/ask-task-with-file  (unique et robuste)
// POST /api/ask-task-with-file  -> lit CSV/JSON, renvoie leads complets + sample
app.post('/api/ask-task-with-file', express.json({ limit: '5mb' }), async (req, res) => {
  try {
    let { prompt, fileType = "csv", fileContent, encoding, mode = "import" } = req.body || {};

    // 1) normaliser en texte
    let raw = normalizeToText(fileContent);

    // 2) d√©coder base64 si besoin
    if (encoding === "base64" && typeof raw === "string") {
      raw = Buffer.from(raw, "base64").toString("utf8");
    }

    if (fileType === "csv") {
      // 3) parser CSV
      const { header, rows, sep } = csvToRows(raw);
      const items = rows.map(r => rowToObj(header, r))
                        .filter(o => (o.email && o.email.length));

      if (items.length === 0) {
        return res.json({
          ok: true,
          reply: "üìé 0 leads import√©s...",
          debug: { sepUsed: sep, header, firstLine: raw.split(/\r?\n/)[0] }
        });
      }

      // √©ventuel traitement (upsert ou tag auto si demand√©)
      if (mode === "upsert" || mode === "upsert+tag") {
        await upsertLeads(items);
      }

      return res.json({
        ok: true,
        reply: `üìé ${items.length} leads import√©s.`,
        count: items.length,
        sepUsed: sep,
        header,
        sample: items.slice(0, 2), // aper√ßu
        leads: items               // ‚ö†Ô∏è liste compl√®te pour React
      });
    }

    return res.status(400).json({ ok: false, error: "fileType non g√©r√©" });

  } catch (e) {
    console.error('ask-task-with-file error:', e);
    res.status(500).json({ ok: false, error: String(e) });
  }
});

// GET /api/task-history?range=24h | 48h | all
app.get('/api/task-history', (req, res) => {
  const { range = 'all' } = req.query;
  const hours = range === '24h' ? 24 : range === '48h' ? 48 : null;
  const data = readTaskHistory(hours);
  res.json({ ok: true, count: data.length, items: data });
});

// 3 derni√®res actions
app.get('/api/task-highlights', (req, res) => {
  res.json({ ok: true, items: latest(3) });
});

// Analyse leads
app.get('/api/leads/analyze', (req, res) => {
  res.json({ ok: true, ...analyzeLeads() });
});

// Suggestions de tags
app.get('/api/tags/suggest', (req, res) => {
  res.json({ ok: true, items: suggestTags() });
});

// ‚úÖ Route pour exposer le fichier d‚Äôhistorique (20 derniers messages)
app.get('/api/history', (req, res) => {
  res.json(getChatHistory());
});
// Middlewares: place as early as possible


// ======== UTIL ========
// timeout simple pour fetch (si tu n'as pas d√©j√† une util similaire)
async function fetchWithTimeout(url, options = {}, timeoutMs = 15000) {
  const ctl = new AbortController();
  const id = setTimeout(() => ctl.abort(), timeoutMs);
  try {
    const res = await fetch(url, { ...options, signal: ctl.signal });
    return res;
  } finally {
    clearTimeout(id);
  }
}

// --- CORRECTIF 3: "askOpenAI" -> "askAI"
// petit wrapper IA : route selon AI_PROVIDER
async function askAI(prompt) {
  const provider = (process.env.AI_PROVIDER || '').toLowerCase().trim(); // 'openai' | 'ollama' | 'mistral' (proxy OpenAI-style √©ventuel)
  const model    = process.env.AI_MODEL || 'gpt-4o-mini';               // ou 'mistral' si Ollama
  const base     = process.env.AI_BASE_URL || '';                        // ex: http://127.0.0.1:11434

  // OPENAI (API officielle)
  if (provider === 'openai') {
    const key = process.env.OPENAI_API_KEY;
    if (!key) throw new Error('OPENAI_API_KEY manquant');
    const res = await fetchWithTimeout('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${key}`, 'Content-Type':'application/json' },
      body: JSON.stringify({
        model,
        messages: [{ role:'user', content: prompt }],
        temperature: 0.7
      })
    }, 20000);
    if (!res.ok) throw new Error(`OPENAI_HTTP_${res.status}`);
    const data = await res.json();
    const txt = data?.choices?.[0]?.message?.content?.trim() || '';
    if (!txt) throw new Error('R√©ponse vide OpenAI');
    return txt;
  }

  // OLLAMA local (ou via Cloudflare) /api/generate
  if (provider === 'ollama') {
    if (!base) throw new Error('AI_BASE_URL requis pour Ollama (ex: http://127.0.0.1:11434)');
    // Si tu passes par Cloudflare Access, ajoute ici tes headers Cf-Access...
    const headers = { 'Content-Type':'application/json' };
    const res = await fetchWithTimeout(`${base.replace(/\/$/, '')}/api/generate`, {
      method: 'POST',
      headers,
      body: JSON.stringify({ model, prompt, stream: false })
    }, 20000);
    if (!res.ok) throw new Error(`OLLAMA_HTTP_${res.status}`);
    const data = await res.json();
    const txt = (data?.response || '').trim();
    if (!txt) throw new Error('R√©ponse vide Ollama');
    return txt;
  }

  // fallback simple si provider non configur√©
  return `M.A.X. (fallback): "${prompt}" bien re√ßu. Configure AI_PROVIDER=openai ou ollama pour activer l'IA.`;
}

// ======== HANDLERS R√âELS ========

// /api/ask (court, sans m√©moire)
app.post('/api/ask', async (req, res) => {
  const msg = (req.body?.message || '').trim();
  if (!msg) return res.status(400).json({ ok:false, error:'MESSAGE_REQUIRED' });

  log('[ASK] in', msg);
  try {
    // --- CORRECTIF 3: "askOpenAI" -> "askAI"
    const answer = await askAI(msg);
    log('[ASK] out ok');
    return res.json({ ok:true, answer });
  } catch (e) {
    log('[ASK] fail', e.message);
    return res.status(500).json({ ok:false, error:'ASK_FAILED', detail: process.env.NODE_ENV==='dev' ? e.message : undefined });
  }
});

// /api/ask-task (avec wording assistant plus ‚Äúagent‚Äù si tu veux l‚Äô√©tendre plus tard)
app.post('/api/ask-task', async (req, res) => {
  const prompt = (req.body?.prompt || '').trim();
  if (!prompt) return res.status(400).json({ ok:false, error:'PROMPT_REQUIRED' });

  log('[ASK-TASK] in', prompt);
  try {
    // Ici tu pourrais: lire un ‚Äúcontext‚Äù (ex: derniers messages), pinger Espo, etc.
    // --- CORRECTIF 3: "askOpenAI" -> "askAI"
    const reply = await askAI(prompt);
    log('[ASK-TASK] out ok');
    return res.json({ ok:true, reply });
  } catch (e) {
    log('[ASK-TASK] fail', e.message);
    return res.status(500).json({ ok:false, error:'ASK_TASK_FAILED', detail: process.env.NODE_ENV==='dev' ? e.message : undefined });
  }
});
// --- Stack diagnostic route ---
app.get('/api/__stack', (_req, res) => {
  const stack = (app._router?.stack || []).map((layer, idx) => {
    if (layer.route) {
      return { idx, path: layer.route.path, methods: Object.keys(layer.route.methods || {}) };
    }
    return { idx, name: layer.name || 'middleware', handle: (layer?.handle?.name || 'anonymous') };
  });
  res.json({ count: stack.length, stack });
});
// --- Utils pagination s√ªrs (Espo autorise ~200 max par page)
async function getLeadsAll(totalLimit = 1000, pageSize = 200) {
  const all = [];
  let offset = 0;
  const page = Math.min(Math.max(1, pageSize), 200); // 1..200

  while (all.length < totalLimit) {
    const size = Math.min(page, totalLimit - all.length);
    const chunk = await getAllLeads(`?maxSize=${size}&offset=${offset}`);
    if (!chunk || chunk.length === 0) break;
    all.push(...chunk);
    if (chunk.length < size) break; // plus rien
    offset += size;
  }
  return all;
}

// --- Routers mont√©s dynamiquement (ex√©cutions, etiquettes)
const executionsRouter = express.Router();
executionsRouter.get('/', async (req, res) => {
  try {
    const p = path.join(__dirname, 'data', 'execution-log.json');
    if (!fs.existsSync(p)) return res.json([]);
    const raw = fs.readFileSync(p, 'utf8');
    const log = JSON.parse(raw || '[]');
    res.json(log);
  } catch (e) { res.status(500).json({ error: e.message }); }
});
executionsRouter.get('/:filename', async (req, res) => {
  try {
    const p = path.join(__dirname, 'data', 'execution-log.json');
    if (!fs.existsSync(p)) return res.status(404).json({ error: 'no log' });
    const raw = fs.readFileSync(p, 'utf8');
    const log = JSON.parse(raw || '[]');
    const item = log.find(x => x.filename === req.params.filename);
    if (!item) return res.status(404).json({ error: 'not found' });
    res.json(item);
  } catch (e) { res.status(500).json({ error: e.message }); }
});
executionsRouter.post('/', async (req, res) => {
  try {
    const entry = {
      date: new Date().toISOString(),
      action: req.body.action || 'manual',
      filename: req.body.filename || null,
      result: req.body.result || 'OK'
    };
    const p = path.join(__dirname, 'data', 'execution-log.json');
    let log = [];
    try { log = JSON.parse(fs.readFileSync(p, 'utf8') || '[]'); } catch {}
    log.push(entry);
    fs.mkdirSync(path.join(__dirname, 'data'), { recursive: true });
    fs.writeFileSync(p, JSON.stringify(log, null, 2), 'utf8');
    res.json({ ok: true, entry });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

const etiquettesRouter = express.Router();
// GET list of tags (Espo Tag entity)
etiquettesRouter.get('/', async (req, res) => {
  try {
  const data = await espo('GET', 'Tag?maxSize=200');
    const list = data.list || [];
    res.json(list);
  } catch (e) { res.status(500).json({ error: e.message }); }
});
// Create a tag
etiquettesRouter.post('/', async (req, res) => {
  try {
    const name = (req.body.name || req.body.label || '').toString().trim();
    if (!name) return res.status(400).json({ error: 'name required' });
  const created = await espo('POST', 'Tag', { body: JSON.stringify({ name }), headers: { 'Content-Type': 'application/json' } });
    res.json(created);
  } catch (e) { res.status(500).json({ error: e.message }); }
});
// Delete tag
etiquettesRouter.delete('/:id', async (req, res) => {
  try {
  await espo('DELETE', `Tag/${req.params.id}`);
    res.json({ ok: true });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// Mount routers
app.use('/api/executions', executionsRouter);
app.use('/api/espo/etiquettes', etiquettesRouter);

// simple ping


// --- Debug : distribution des statuts (paginer + param√®tres URL)
app.get('/api/debug/lead-statuses', async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit ?? '600', 10), 5000);
    const pageSize = Math.min(parseInt(req.query.pageSize ?? '200', 10), 200);

    // --- CORRECTIF (faute de frappe): "getLeadsAll" -> "getAllLeads"
    const leads = await getAllLeads(`?maxSize=${limit}`);
    const map = {};
    for (const l of leads) {
      const s = (l.status || l.statut || '‚Äî').toString();
      map[s] = (map[s] || 0) + 1;
    }
    res.json({ total: leads.length, statuses: map });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});
// Debug : √©chantillon brut des leads
app.get('/api/debug/leads-raw', async (_req, res) => {
  try {
    const leads = await getAllLeads('?maxSize=50');
    const sample = leads.slice(0, 10).map(l => {
      const keys = Object.keys(l).sort();
      return {
        id: l.id, name: l.name || `${l.firstName||''} ${l.lastName||''}`.trim(),
        status: l.status || l.statut,
        createdAt: l.createdAt || l.dateCreated || l.created || null,
        tags: l.tags || l.tagList || l.tagNames || null,
        keys
      };
    });
    res.json({ count: leads.length, sample });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// Debug: lire un lead et voir ses tags
app.get('/api/debug/lead/:id', async (req, res) => {
  try {
  const l = await espo('GET', `Lead/${req.params.id}`);
    res.json({
      id: l.id,
      name: l.name || `${l.firstName||''} ${l.lastName||''}`.trim(),
      status: l.status || l.statut,
      createdAt: l.createdAt || l.dateCreated,
      tags: l.tags || l.tagList || l.tagNames || []
    });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// --- CORRECTIF 5: Route "preview" d√©sactiv√©e (cass√©e) ---
/*
// Preview : qui serait tagu√© par le job "tag-rentree"
app.post('/api/actions/tag-rentree/preview', async (req, res) => {
  try {
    // ... ton code m√©tier ici ...
    const since = new Date(); since.setDate(since.getDate() - (sinceDays||0));
    const wanted = (statuses||[]).map(strip);

    const targeted = [], nonMatches = [];
    for (const l of leads) {
      const stRaw = (l.status || l.statut || '').toString();
      const st = strip(stRaw);
      const okStatus = wanted.length===0 ? true : wanted.some(w => st.includes(w));

      const createdRaw = l.createdAt || l.dateCreated || l.created || l.created_at || null;
      const created = createdRaw ? new Date(createdRaw) : null;
      const okRecent = (sinceDays||0) <= 0 ? true : (created ? created >= since : true);

      const rawTags = l.tags || l.tagList || l.tagNames || null;
      const tags = toTagArrayAny(rawTags).map(strip);
      const already = tags.includes(strip('rentr√©e')) || tags.includes('rentree');

      const hit = okStatus && okRecent && !already;
      (hit ? targeted : nonMatches).push({
        id: l.id,
        name: l.name || `${l.firstName||''} ${l.lastName||''}`.trim(),
        status: stRaw,
        createdAt: createdRaw,
        already
      });
    }

    res.json({
      ok: true,
      targetedCount: targeted.length,
      targeted: targeted.slice(0, 50),
      nonMatchesPreview: nonMatches.slice(0, 50)
    });
  } catch (err) {
    log('ERR', 'server.js try/catch zone ~199 ->', err.message);
    if (typeof res !== 'undefined' && res && typeof res.status === 'function') {
      return res.status(500).json({ ok: false, error: 'INTERNAL_ERROR', detail: err.message });
    }
  }
});
*/
// --- Fin du correctif 5 ---


// Route : R√©cup√©rer l'√©tat d'une t√¢che (ex√©cut√©e ou pas)
app.get('/api/executions/by-task/:filename', async (req, res) => {
  const filename = req.params.filename;
  const logPath = path.join(DATA_DIR, 'execution-log.json');

  try {
    const raw = await fs.promises.readFile(logPath, 'utf8');
    const log = JSON.parse(raw);

    const match = log.find(entry => entry.filename === filename);

    if (match) {
      res.json({
        executed: true,
        details: match
      });
    } else {
      res.json({
        executed: false,
        message: "T√¢che non encore valid√©e par M.A.X."
      });
    }
  } catch (err) {
    res.status(500).json({ error: 'Impossible de lire execution-log.json', reason: err.message });
  }
});


// --- Action : G√©n√©rer une t√¢che "Campagne rentr√©e" (newsletter + WhatsApp)
app.post('/api/actions/create-campaign-rentree', async (req, res) => {
  try {
    const ctx = agentIdentity?.contexte_client || {};
    const task = {
      task: "campaign_rentree_damath",
      description: "Relance newsletter + WhatsApp sp√©ciale rentr√©e (Damath)",
      action: "campaign_rentree",
      createdAt: new Date().toISOString(),
      payload: {
        client: ctx.nom || "Damath Overseas",
        segmentRules: { statuses: ["Nouveau", "√Ä contacter"], tags: ["rentr√©e"] },
        email: {
          subject: "Offre sp√©ciale rentr√©e ‚Äì exp√©diez au meilleur tarif",
          preview: "Rentr√©e: groupage, enl√®vement, tarifs promo",
          variables: ["firstName","ville","type_envoi"]
        },
        whatsapp: {
          template: "Bonjour {{firstName}}, c‚Äôest Damath Overseas. Pour la rentr√©e, tarif sp√©cial pour vos envois vers Madagascar. Voulez-vous qu‚Äôon s‚Äôoccupe du devis ?"
        },
        n8nWebhook: process.env.N8N_WEBHOOK_URL || null
      }
    };

    if (!fs.existsSync(TASKS_DIR)) fs.mkdirSync(TASKS_DIR, { recursive: true });
    const filename = `campaign_rentree_${Date.now()}.json`;
    fs.writeFileSync(path.join(TASKS_DIR, filename), JSON.stringify(task, null, 2), 'utf8');
    // --- CORRECTIF 4: "saveToHistory" -> "saveChatHistory"
    saveChatHistory('system', `T√¢che cr√©√©e: ${filename}`);

    res.json({ ok: true, filename, task });
  } catch (e) {
    console.error('‚ùå /api/actions/create-campaign-rentree', e.message);
    res.status(500).json({ ok: false, error: e.message });
  }
});



// --- Action : Tag "rentr√©e" sur les nouveaux leads r√©cents
app.post('/api/actions/tag-rentree', async (req, res) => {
  try {
    const {
      statuses = ['Nouveau', '√Ä contacter', 'A contacter', 'New'],
      sinceDays = 7,
      limit = 600,
      pageSize = 200
    } = req.body || {};

    const since = new Date(); since.setDate(since.getDate() - (sinceDays||0));
    // --- CORRECTIF (faute de frappe): "getLeadsAll" -> "getAllLeads"
    const leads = await getAllLeads(`?maxSize=${limit}`);

    const norm = s => (s||'').toString().normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase();
    const toArrayTags = t => {
      if (!t) return [];
      if (Array.isArray(t)) return t;
      if (typeof t === 'string') return t.split(',').map(x=>x.trim()).filter(Boolean);
      if (typeof t === 'object') return Object.keys(t);
      return [];
    };

    const wanted = (statuses||[]).map(norm);

    const targeted = [];
    for (const l of leads) {
      const rawStatus = (l.status || l.statut || '').toString();
      const st = norm(rawStatus);
      const okStatus = wanted.length === 0 ? true : wanted.some(w => st.includes(w));

      const createdRaw = l.createdAt || l.dateCreated || l.created || l.created_at || null;
      const created = createdRaw ? new Date(createdRaw) : null;
      const okRecent = (sinceDays||0) <= 0 ? true : (created ? created >= since : true);

      const rawTags = l.tags || l.tagList || l.tagNames || null;
      const tags = toArrayTags(rawTags).map(norm);
      const hasRentree = tags.includes(norm('rentr√©e')) || tags.includes('rentree');

      if (okStatus && okRecent && !hasRentree) targeted.push(l);
    }

    let updated = 0, errors = [];
    for (const lead of targeted) {
      try {
        await patchLeadTags(lead.id, ['rentr√©e']);
        updated++;
      } catch (e) {
        errors.push({ id: lead.id, error: e.message });
      }
    }

    res.json({ ok: true, targeted: targeted.length, updated, errors });
  } catch (e) {
    console.error('‚ùå /api/actions/tag-rentree', e.message);
    res.status(500).json({ ok: false, error: e.message });
  }
});

// --- CORRECTIF 5: Route "strategy" d√©sactiv√©e (cass√©e) ---
/*
// --- Strat√©gie de tagging IA pour leads
app.post('/api/strategy/propose-tags', async (req, res) => {
  try {
    const leads = await getAllLeads('?maxSize=100');
    const context = agentIdentity?.contexte_client || {};

    const shortLeads = leads.map(l => ({
      nom: l.firstName + ' ' + l.lastName,
      statut: l.status,
      source: l.source,
      tags: l.tags,
      createdAt: l.createdAt
    }));

    const prompt = `\nTu es un assistant IA CRM int√©gr√© √† EspoCRM.\n\nLe client est : ${context.nom ?? 'non pr√©cis√©'} ‚Äì ${context.secteur ?? 'non pr√©cis√©'}.\n\nObjectifs commerciaux :\n${(context.objectifs_commerciaux || []).map(o => "- " + o).join('\n')}\n\nTags utiles possibles :\n${(context.tags_utiles || []).join(', ')}\n\nVoici 10 leads r√©cents :\n${shortLeads.slice(0, 10).map(l => `- ${l.nom} | ${l.statut} | ${l.source} | ${l.tags?.join(', ') || '‚Äî'} | ${l.createdAt}`).join('\n')}\n\nAnalyse ces leads et propose :\n1. ‚úÖ Les tags √† ajouter cette semaine (avec contexte)\n2. üß† Des segments utiles pour automatiser les actions\n3. ‚ö°Ô∏è Des actions CRM ou marketing (WhatsApp, email, n8n)\n\nSois synth√©tique, structur√©, et pragmatique.\n`;

    // --- CORRECTIF 3: "askOpenAI" -> "askAI"
    const reply = await askAI(prompt);
    // --- CORRECTIF 4: "saveToHistory" -> "saveChatHistory"
    saveChatHistory('user', '[M.A.X. strat√©gie de tagging]');
    saveChatHistory('assistant', reply);

    res.json({ ok: true, prompt, reply });
  } catch (e) {
    console.error('/api/strategy/propose-tags error:', e.message);
    res.status(500).json({ ok: false, error: e.message });
  }
});
*/
// --- Fin du correctif 5 ---

app.use('/api/analyze-result', analyzeResultRoutes);

// --- SELFTEST inline (pour v√©rifier le montage global Express) ---


// --- SELFTEST inline sur le m√™me pr√©fixe (prouve que le pr√©fixe est OK) ---
app.get('/api/actions/etiquette/__selftest-inline', (_req, res) => res.json({ ok: true, from: 'inline' }));

// --- Montage de la route ETIQUETTES + log d'acc√®s ---
app.use('/api/actions/etiquette',
  (req, _res, next) => { console.log('>> [etiquette] hit:', req.method, req.url); next(); },
  etqActionsRoutes
);

// Ajout tag "rentr√©e" sur 1 lead (body.leadId OU ?leadId= OU /:id)
app.all('/api/actions/tag-one/:id?', async (req, res) => {
  try {
    const id =
      (req.body && (req.body.leadId || req.body.id)) ||
      req.query.leadId ||
      req.params.id;

    if (!id) {
      return res.status(400).json({
        ok: false,
        error: "leadId requis (body.leadId, ?leadId=, ou /api/actions/tag-one/:id)"
      });
    }

    const r = await patchLeadTags(id, ['rentr√©e']);
    res.json({ ok: true, updated: id, result: r });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});


app.get('/api/analyze-result', (req, res) => {
  const file = path.join(process.cwd(), 'data', 'analyze-result.json');
  if (!fs.existsSync(file)) return res.status(404).json({ error: 'Fichier non trouv√©' });

  try {
    const raw = fs.readFileSync(file, 'utf8');
    const json = JSON.parse(raw);

    let items = [];
    if (Array.isArray(json)) {
      items = json;
    } else if (Array.isArray(json?.items)) {
      items = json.items;
    } else {
      // objet numerot√© -> le convertir en tableau
      items = Object.values(json)
        .filter(v => v && typeof v === 'object' && ('id' in v || 'fullName' in v));
    }

    res.json({ items });
  } catch (e) {
    console.error('‚ùå analyze-result.json invalide :', e.message);
    res.status(500).json({ error: 'Fichier JSON invalide' });
  }
});

// --- CORRECTIF: Imports dupliqu√©s supprim√©s d'ici ---

// üîç V√©rification environnement
const ESPO_URL = process.env.ESPO_URL;
const ESPO_API_KEY = process.env.ESPO_API_KEY;

function normalizeBase(u) {
  let base = (u || 'http://127.0.0.1:8081').toString().trim();
  // si quelqu‚Äôun a mis /api/v1/... dans ESPO_URL, on l‚Äôenl√®ve
  base = base.replace(/\/api\/v\d+.*$/i, '');
  return base.replace(/\/+$/, '');
}

const BASE = normalizeBase(ESPO_URL);
function espoUrl(p) {
  return `${BASE}/api/v1/${String(p).replace(/^\/+/, '')}`;
}


// Statut auth Espo
app.get('/api/__espo-status', async (req, res) => {
  try {
    const ping = await espo('GET', 'Lead?maxSize=1');
    res.json({
      ok: true,
      base: process.env.ESPO_BASE_URL || process.env.ESPO_URL,
      sample: Array.isArray(ping?.list) ? ping.list.length : (ping?.total ?? 0),
    });
  } catch (e) {
    res.status(503).json({ ok: false, error: String(e) });
  }
});

// Probe (m√™me client)
app.get('/api/actions/etiquette/_probe', async (req, res) => {
  try {
    const sample = await espo('GET', 'Lead?maxSize=1');
    res.json({ ok:true, espo: process.env.ESPO_BASE_URL, sample: sample?.list?.length ?? 0 });
  } catch (e) {
    res.status(500).json({ ok:false, error:String(e) });
  }
});
// --- utilitaire local
function parseTagsFromDescription(desc) {
  const m = /\bTAGS?\s*:\s*([^\n]+)/i.exec(desc || '');
  if (!m) return [];
  return m[1]
    .split(/[,\s#;]+/)
    .map(s => s.trim())
    .filter(Boolean);
}

app.get('/api/espo/lead/:id/tags', async (req, res) => {
  try {
    const { id } = req.params;
    // on lit TOUT ce qui peut contenir des tags + description pour fallback
    const lead = await espo('GET', `Lead/${encodeURIComponent(id)}?select=name,description,tagNames,etiquettesNames,tags`);
    // priorit√©: etiquettesNames -> tagNames -> tags -> "TAGS:" dans la description
    let tags = [];
    const candidates = [lead?.etiquettesNames, lead?.tagNames, lead?.tags];
    for (const c of candidates) {
      if (Array.isArray(c) && c.length) { tags = c; break; }
      if (c && typeof c === 'object') { tags = Object.keys(c); if (tags.length) break; }
      if (typeof c === 'string' && c.trim()) { tags = c.split(',').map(s => s.trim()); if (tags.length) break; }
    }
    if (!tags.length) tags = parseTagsFromDescription(lead?.description);

    return res.json({ ok: true, id, name: lead?.name ?? null, tags });
  } catch (e) {
    return res.status(404).json({ ok: false, error: String(e) });
  }
});

// --- Helpers (dates & tags)
function daysAgo(n) { const d = new Date(); d.setDate(d.getDate() - n); return d; }
function normalizeTags(t) {
  if (!t) return [];
  if (Array.isArray(t)) return t;
  if (typeof t === 'string') return t.split(',').map(s => s.trim()).filter(Boolean);
  return [];
}
function toTagArrayAny(raw) {
  if (!raw) return [];
  if (Array.isArray(raw)) return raw;
  if (typeof raw === 'string') return raw.split(',').map(s => s.trim()).filter(Boolean);
  if (typeof raw === 'object') return Object.keys(raw); // ex. { "rentr√©e": true }
  return [];
}

function toTagPayloadLike(rawBefore, tagsArray) {
  // Si initialement c'√©tait un objet -> renvoyer un objet { tag: true }
  if (rawBefore && typeof rawBefore === 'object' && !Array.isArray(rawBefore)) {
    const obj = {};
    for (const t of tagsArray) obj[t] = true;
    return obj;
  }
  // Sinon, tableau
  return tagsArray;
}

async function patchLeadTags(id, add = [], remove = [], fields = {}) {
  const lead = await espo('GET', `Lead/${id}`);

  // Si l'entit√© Lead a une relation 'tags', utiliser linkMany via ensureTagId
  try {
    const links = await getMetadata('entityDefs.Lead.links');
    if (links?.tags) {
      const ids = [];
      for (const t of add) {
        const tid = await ensureTagId(t);
        ids.push(tid);
      }
      if (ids.length) {
        await linkMany('Lead', id, 'tags', ids);
        return { ok: true, mode: 'link', linked: ids.length };
      }
    }
  } catch (e) {
    // fallback to patching the tags field
  }

  const current = toTagArrayAny(lead.tags || lead.tagList || lead.tagNames);
  const merged = new Set(current);
  add.forEach(t => merged.add(t));
  remove.forEach(t => merged.delete(t));

  const newTagsArr = Array.from(merged);
  const tagsPayload = toTagPayloadLike(lead.tags, newTagsArr);
  const payload = { ...fields, tags: tagsPayload };

  // --- MODIFI√â: `body` doit √™tre un objet, pas une string
  return espo('PATCH', `Lead/${id}`, payload);
}

// Applique un tag √† une liste de leads via EspoCRM, avec fallback description(TAGS: ...)
async function espoApplyTagToLeads(tagKey, leadIds = []) {
  if (!tagKey || !Array.isArray(leadIds) || leadIds.length === 0) {
    return { ok: true, updated: 0 };
  }
  let updated = 0;
  let failed = 0;
  for (const id of leadIds) {
    try {
      await patchLeadTags(id, [tagKey]);
      updated++;
      continue;
    } catch (e) {
      // fallback: √©crire dans description sous forme "TAGS: #key ..."
      try {
        const lead = await espo('GET', `Lead/${encodeURIComponent(id)}?select=id,description`);
        const existing = parseTagsFromDescription(lead?.description);
        const merged = Array.from(new Set([...(existing || []), tagKey]));
        const description = upsertTagsInDescription(lead?.description || '', merged);
        // --- MODIFI√â: `body` doit √™tre un objet
        await espo('PATCH', `Lead/${encodeURIComponent(id)}`, { description });
        updated++;
      } catch (e2) {
        failed++;
        console.warn('[espoApplyTagToLeads] failed for', id, e2?.message || e2);
      }
    }
  }
  return { ok: true, updated, failed };
}

// --- PATCH lead avec tags dynamiques (ancr√© dans le plan projet)
app.patch('/api/crm/update-lead/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { tagsToAdd = [], tagsToRemove = [], ...fields } = req.body || {};

    // 1. Lire le lead actuel
  const lead = await espo('GET', `Lead/${id}`);
    const currentTags = Array.isArray(lead.tags) ? lead.tags : [];

    // 2. Merger proprement les tags
    const merged = new Set(currentTags);
    tagsToAdd.forEach(t => merged.add(t));
    tagsToRemove.forEach(t => merged.delete(t));

    const finalTags = Array.from(merged);

    // 3. Mettre √† jour le lead
    const patch = { ...fields, tags: finalTags };
    // --- MODIFI√â: `body` doit √™tre un objet
    const updated = await espo('PATCH', `Lead/${id}`, patch);

    res.json({ ok: true, updated });
  } catch (e) {
    console.error('‚ùå PATCH /api/crm/update-lead/:id', e.message);
    res.status(500).json({ ok: false, error: e.message });
  }
});

// --- Config ---
// Test API EspoCRM (fetchEspo)

const PORT = process.env.PORT || 3005;
const BIND_HOST = process.env.BIND_HOST || '127.0.0.1';
const TASKS_DIR = process.env.TASKS_DIR || path.join(__dirname, '..', 'ia_admin', 'tasks_autogen'); // fallback
const BACKUP_ROOT = process.env.BACKUP_ROOT || path.join(__dirname, '..', 'backups', 'react');
const REACT_SRC_DIR = process.env.REACT_SRC_DIR || path.join(__dirname, '..', 'ia-admin-ui', 'src');
// DATA_DIR est d√©j√† d√©fini en haut (correctif 2)
if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });

const HISTORY_PATH = path.join(DATA_DIR, 'chat-history.json');
// AGENT_IDENTITY_PATH est d√©j√† d√©fini en haut (correctif 2)
const PROJECT_MAP_PATH = path.join(__dirname, '..', 'ia_admin_api', 'project-map.json'); // keep compatibility

// --- CORRECTIF 2: Bloc "agentIdentity" supprim√© d'ici (d√©plac√© en haut) ---

// --- Helpers: safe filenames, history, read/write ---
function isSafeReactFile(filename) {
  return /^[\w\-.]+\.jsx?$/.test(filename);
}

function readJSONSafe(p, defaultValue = null) {
  try {
    if (!fs.existsSync(p)) return defaultValue;
    return JSON.parse(fs.readFileSync(p, 'utf8'));
  } catch (e) {
    console.error('readJSONSafe error', p, e.message);
    return defaultValue;
  }
}

function writeJSONSafe(p, obj) {
  try {
    fs.writeFileSync(p, JSON.stringify(obj, null, 2), 'utf8');
    return true;
  } catch (e) {
    console.error('writeJSONSafe error', p, e.message);
    return false;
  }
}

// Chat history helpers
function getHistory() {
  return readJSONSafe(HISTORY_PATH, []);
}

function saveChatHistoryLocal(message) {
  const path = './data/chat-history.json';
  const log = readJSONSafe(path) || [];

  // Si pas d√©j√† timestamp√©, ajoute le timestamp
  if (!message.timestamp) {
    message.timestamp = new Date().toISOString();
  }

  log.push(message);
  fs.writeFileSync(path, JSON.stringify(log.slice(-500), null, 2), 'utf8'); // max 500 lignes
}
function getLastMessages(n = 10) {
  const h = getHistory();
  return h.slice(-n);
}

// --- Small utilities ---
function safeJsonParse(str) {
  try { return JSON.parse(str); } catch { return null; }
}

// Build prompt for LLM using agent identity + recent history
function buildPrompt(userPrompt, chatHistory = []) {
  const identitySection = `
Tu es ${agentIdentity.nom}, un ${agentIdentity.type}.
Mission : ${agentIdentity.role}

Projet : ${agentIdentity.contexte_projet?.projet ?? 'non sp√©cifi√©'}
Utilisation : ${agentIdentity.contexte_projet?.utilisation ?? 'non sp√©cifi√©'}
Mission m√©tier : ${agentIdentity.contexte_projet?.mission_metier ?? ''}

Voici tes permissions :
${(agentIdentity.permissions || []).map(p => `- ${p}`).join('\n')}

Objectifs :
${(agentIdentity.objectifs || []).map(o => `- ${o}`).join('\n')}

Personnalit√© : ${agentIdentity['personnalite'] || ''}
`.trim();

  const capabilities = `
Voici ce que tu peux faire :

- Importer des leads via CSV
- Ajouter des leads dans le CRM Espo
- Appliquer automatiquement des tags
- Sugg√©rer des campagnes de relance

Si on te donne une t√¢che, tu dois r√©pondre en l'ex√©cutant si c'est possible.
Sinon, explique pourquoi.

Demande actuelle : ${userPrompt}`.trim();

  const historyText = (chatHistory.length ? chatHistory.map(h => `${h.role.toUpperCase()}: ${h.content || h.message || ''}`).join('\n') : '');
  return `${identitySection}\n\n${capabilities}\n\nContexte r√©cent :\n${historyText}`;
}

// --- CORRECTIF 1 ET 3 : Fonction "askOpenAI" en double supprim√©e d'ici ---

// --- ROUTES EXPRESS ---

// Test API EspoCRM (fetchEspo)


// Sant√© API Espo (test auth + reach)
app.get('/api/crm/health', async (_req, res) => {
  try { await espo('GET', 'I18n'); res.json({ ok: true }); }
  catch (e) { res.status(500).json({ ok:false, error: e.message }); }
});

// --- AJOUT (depuis votre plan) : Route de cr√©ation de Lead ---
app.post('/api/crm/Lead', async (req, res) => {
  const body = req.body || {};
  if (!Object.keys(body).length) {
    return res.status(400).json({ ok:false, crmOnline:true, status:400,
      error:"Le corps de la requ√™te (body) est vide. Le lead n'a pas √©t√© transmis." });
  }
  try {
    const created = await espo('POST', 'Lead', body);  // ‚¨ÖÔ∏è objet direct, pas JSON.stringify
    if (!created || created.error) {
      return res.status(409).json({ ok:false, crmOnline:true, status:409,
        error: created?.error || 'Lead non cr√©√© (validation/doublon).', details: created || null });
    }
    res.json({ ok:true, crmOnline:true, id: created.id, data: created });
  } catch (e) {
    res.status(503).json({ ok:false, crmOnline:false, error:e.message });
  }
});
// --- Fin de l'ajout ---


// Met √† jour des champs simples (statut, custom fields‚Ä¶)
app.post('/api/crm/:entity/:id/update', async (req, res) => {
  try {
    const { entity, id } = req.params;
    const { patch } = req.body || {};
    if (!patch || typeof patch !== 'object') throw new Error('patch object required');
    const updated = await updateEntity(entity, id, patch);
    res.json({ ok: true, updated });
  } catch (e) { res.status(500).json({ ok:false, error: e.message }); }
});


// --- Routes utilitaires pour le log et le diagnostic ---
app.get('/api/__ping-log', (_req, res) => {
  log('PING LOG OK');
  res.json({ ok: true });
});

// Canonical routes listing (single handler kept)
app.get('/api/__routes', (_req, res) => {
  const routes = [];
  (app._router?.stack || []).forEach((m) => {
    if (m.route && m.route.path) {
      const methods = Object.keys(m.route.methods || {}).map(k => k.toUpperCase()).filter(Boolean);
      routes.push({ path: m.route.path, methods });
    }
  });
  res.json({ ok: true, routesCount: routes.length, routes });
});

// --- Endpoints Espo utiles (health & lead tags)
// ... (doublons de routes supprim√©s) ...

// 1) Lookup Espo par email
app.get('/api/espo/lead/by-email', async (req, res) => {
  try {
    const email = String(req.query.email || '').trim();
    if (!email) return res.status(400).json({ ok:false, error:'email requis' });

    const where = encodeURIComponent(JSON.stringify([
      { type: 'equals', attribute: 'emailAddress', value: email }
    ]));
    const select = encodeURIComponent('id,name,emailAddress,phoneNumber,tagNames,etiquettesNames');
    const url = `Lead?maxSize=5&where=${where}&select=${select}`;

    const resp = await espo('GET', url);
    const items = (resp?.list || []).map(i => ({
      id: i.id,
      name: i.name,
      email: i.emailAddress ?? null,
      phone: i.phoneNumber ?? null,
      tags: i.etiquettesNames ?? i.tagNames ?? [],
    }));
    res.json({ ok:true, count: items.length, items });
  } catch (e) {
    res.status(503).json({ ok:false, error:String(e) });
  }
});

// 2) Lookup Espo par t√©l√©phone
app.get('/api/espo/lead/by-phone', async (req, res) => {
  try {
    const phone = String(req.query.phone || '').trim();
    if (!phone) return res.status(400).json({ ok:false, error:'phone requis' });

    const resp = await espo('GET', `Lead?maxSize=5&q=${encodeURIComponent(phone)}&select=id,name,tagNames,etiquettesNames,phoneNumber`);
    const items = (resp?.list || []).map(i => ({
      id: i.id,
      name: i.name,
      phone: i.phoneNumber || phone,
      tags: i.etiquettesNames ?? i.tagNames ?? []
    }));
    res.json({ ok:true, count: items.length, items });
  } catch (e) {
    res.status(503).json({ ok:false, error:String(e) });
  }
});

// POST /api/espo/upsert-lead  { firstName,lastName,email,phone,source,status }
app.post('/api/espo/upsert-lead', async (req, res) => {
  try {
    const { firstName='', lastName='', email='', phone='', source='Website', status='In Process' } = req.body || {};
    if (!email) return res.status(400).json({ ok:false, error:'email requis' });

    const where = encodeURIComponent(JSON.stringify([{ type:'equals', attribute:'emailAddress', value: email }]));
    const found = await espo('GET', `Lead?maxSize=1&where=${where}&select=id`);
    let id = found?.list?.[0]?.id;

    if (!id) {
      // --- MODIFI√â: `body` doit √™tre un objet
      const created = await espo('POST', 'Lead', { firstName, lastName, emailAddress: email, phoneNumber: phone, source, status });
      id = created?.id;
    }

    res.json({ ok:true, id });
  } catch (e) {
    res.status(503).json({ ok:false, error:String(e) });
  }
});

// 3) Lire les tags d‚Äôun lead Espo par ID (si tu as d√©j√† l'ID Espo)
// Remplace la ligne TAGS: dans description (ou l‚Äôajoute)
function upsertTagsInDescription(desc, tagsArr) {
  const base = (desc || '').replace(/^\s*(TAGS?|#tags?)\s*:.+$/gmi, '').trim();
  const line = `TAGS: ${[...new Set(tagsArr)].map(t => `#${t}`).join(' ')}`;
  return base ? `${base}\n${line}` : line;
}

app.post('/api/crm/lead/:id/tags', async (req, res) => {
  try {
    const leadId = req.params.id;
    const names = (req.body?.tags || []).map(s => String(s).trim()).filter(Boolean);
    if (!names.length) return res.status(400).json({ ok: false, error: 'tags array required' });

    // lire le lead et fusionner avec tags d√©j√† pr√©sents dans description
    const lead = await espo('GET', `Lead/${encodeURIComponent(leadId)}?select=id,name,description`);
    const existing = (function parse(desc) {
      const m = /\bTAGS?\s*:\s*([^\n]+)/i.exec(desc || '');
      if (!m) return [];
      return m[1].split(/[,\s#;]+/).map(s => s.trim()).filter(Boolean);
    })(lead?.description);

    const merged = Array.from(new Set([...existing, ...names]));
    const description = upsertTagsInDescription(lead?.description || '', merged);

    // --- MODIFI√â: `body` doit √™tre un objet
    const updated = await espo('PATCH', `Lead/${encodeURIComponent(leadId)}`, { description });
    return res.json({ ok: true, mode: 'description(TAGS: ...)', updated });
  } catch (e) {
    return res.status(500).json({ ok: false, error: e.message });
  }
});

// ... (doublons de routes supprim√©s) ...

// serve project-map.json if exists
app.get('/project-map.json', (req, res) => {
  const p = path.join(process.cwd(), 'project-map.json');
  if (fs.existsSync(p)) return res.sendFile(p);
  return res.status(404).json({ error: 'project-map.json non trouv√©' });
});

// list tasks
app.get('/api/tasks', (req, res) => {
  try {
    const tasksDir = TASKS_DIR;
    if (!fs.existsSync(tasksDir)) fs.mkdirSync(tasksDir, { recursive: true });
    const files = fs.readdirSync(tasksDir).filter(f => f.endsWith('.json'));
    const tasks = files.map(f => {
      const content = safeJsonParse(fs.readFileSync(path.join(tasksDir, f), 'utf8'));
      return { filename: f, content };
    });
    res.json(tasks);
  } catch (e) {
    console.error('/api/tasks', e.message);
    res.status(500).json({ error: e.message });
  }
});

// create task
app.post('/api/tasks/create', (req, res) => {
  try {
    const { name = 'task', description = '', payload = {} } = req.body;
    const timestamp = Date.now();
    const filename = `${name.replace(/[^\w\-]/g, '_')}-${timestamp}.json`;
    if (!fs.existsSync(TASKS_DIR)) fs.mkdirSync(TASKS_DIR, { recursive: true });
    const taskPath = path.join(TASKS_DIR, filename);
    const taskData = { task: name, description, action: payload.action || 'custom', createdAt: new Date().toISOString(), payload };
    fs.writeFileSync(taskPath, JSON.stringify(taskData, null, 2), 'utf8');
    // --- CORRECTIF 4: "saveToHistory" -> "saveChatHistory"
    saveChatHistory('system', `T√¢che cr√©√©e: ${filename}`);
    res.json({ ok: true, filename, task: taskData });
  } catch (e) {
    console.error('/api/tasks/create', e.message);
    res.status(500).json({ error: e.message });
  }
});

// delete task
app.delete('/api/tasks/:filename', (req, res) => {
  try {
    const p = path.join(TASKS_DIR, req.params.filename);
    if (fs.existsSync(p)) fs.unlinkSync(p);
    res.json({ ok: true });
  } catch (e) {
    console.error('/api/tasks/:filename delete', e.message);
    res.status(500).json({ error: e.message });
  }
});

// validate/execute task
app.post('/api/tasks/:filename/validate', (req, res) => {
  try {
    const p = path.join(TASKS_DIR, req.params.filename);
    if (!fs.existsSync(p)) return res.status(404).json({ error: 'task not found' });
    const payload = JSON.parse(fs.readFileSync(p, 'utf8'));

    // --- CORRECTIF 4: "saveToHistory" -> "saveChatHistory"
    saveChatHistory('system', `Validation de la t√¢che ${req.params.filename}`);

    // handle known actions
    if (payload.action === 'generate_project_map' || payload.task === 'generate_crm_map') {
      const structure = payload.structure || payload.payload?.structure || {};
      const outPath = path.join(process.cwd(), 'project-map.json');
      fs.writeFileSync(outPath, JSON.stringify(structure, null, 2), 'utf8');
      say(`J‚Äôai analys√© l‚Äôenvironnement. La carte mentale est pr√™te.`);
      // Ajout log execution
      logExecution(req.params.filename, "Validation t√¢che MAX");
      return res.json({ ok: true, action: 'generate_project_map' });
    }

    // default: mark validated
    // Ajout log execution
    logExecution(req.params.filename, "Validation t√¢che MAX");
    return res.json({ ok: true, forwarded: !!process.env.N8N_WEBHOOK_URL });
  } catch (e) {
    console.error('/api/tasks/:filename/validate', e.message);
    res.status(500).json({ error: e.message });
  }
});

// === PATCH MINIMAL TASK STORE & LOGGING ===
const TASKS_STORE_DIR = path.join(__dirname, 'tasks');
if (!fs.existsSync(TASKS_STORE_DIR)) fs.mkdirSync(TASKS_STORE_DIR, { recursive: true });

function loadTask(filename) {
  const p = path.join(TASKS_STORE_DIR, filename);
  if (!fs.existsSync(p)) throw new Error('task not found: ' + filename);
  const raw = fs.readFileSync(p, 'utf8');
  const task = JSON.parse(raw);
  task._filename = filename;
  task.logs = task.logs || [];
  return task;
}

function saveTask(task) {
  const filename = task._filename || task.filename || `task-${Date.now()}.json`;
  task._filename = filename;
  const p = path.join(TASKS_STORE_DIR, filename);
  fs.writeFileSync(p, JSON.stringify(task, null, 2), 'utf8');
  return filename;
}

// task-local logging (keeps separate from the existing logExecution that writes execution-log.json)
function logTaskExecution(task, level, msg, meta) {
  task.logs = task.logs || [];
  task.logs.push({ t: Date.now(), level, msg, meta });
  task.updatedAt = new Date().toISOString();
}

// Utilitaire: safe get status from body
function normalizeStatus(s) {
  const allowed = new Set(['queued','running','waiting_validation','success','failed','canceled']);
  return allowed.has(s) ? s : undefined;
}
// === FIN PATCH ===

// Remplacement /api/tasks/:id/validate -> charge la task, passe en queued et la sauvegarde
app.post('/api/tasks/:id/validate', async (req, res) => {
  try {
    const idOrFilename = req.params.id; // ex: task-1762089977744.json
    let task = loadTask(idOrFilename);

    // Passe la task en "queued" (pr√™te √† partir vers n8n)
    task.status = 'queued';
    logTaskExecution(task, 'info', 'Task validated -> queued', { step: 'validate' });
    saveTask(task);

    return res.json({ ok: true, id: idOrFilename, status: task.status });
  } catch (e) {
    console.error(e);
    return res.status(500).json({ ok: false, error: 'VALIDATE_FAILED', detail: String(e) });
  }
});

// Callback de statut (ex: n8n -> M.A.X.) : met √† jour status, crmLinks, logs
app.post('/api/tasks/:id/status', express.json(), async (req, res) => {
  try {
    const idOrFilename = req.params.id;
    let task = loadTask(idOrFilename);

    const { status, message, meta, crm } = req.body || {};
    const safeStatus = normalizeStatus(status);
    if (safeStatus) task.status = safeStatus;

    if (crm) {
      task.crmLinks = Object.assign({}, task.crmLinks || {}, crm);
    }

    logTaskExecution(task, 'info', message || `status:${safeStatus || 'unknown'}`, meta);
    saveTask(task);

    return res.json({ ok: true, id: idOrFilename, status: task.status, crm: task.crmLinks });
  } catch (e) {
    console.error(e);
    return res.status(500).json({ ok: false, error: 'STATUS_UPDATE_FAILED', detail: String(e) });
  }
});

// --- Debug
app.get('/api/debug/agent-identity', (req, res) => {
  res.json({ ok: true, agentIdentity });
});

// --- Action : Tag "rentr√©e" sur les nouveaux leads r√©cents (version simplifi√©e)
app.post('/api/actions/tag-rentree/simple', async (req, res) => {
  try {
    const sinceDays = 7;
    const since = new Date(); since.setDate(since.getDate() - sinceDays);
    const tag = 'rentr√©e';

    // 1. Chercher les leads r√©cents
    const leads = await getAllLeads(`?maxSize=100`);
    const targeted = leads.filter(l => {
      const created = new Date(l.createdAt || l.dateCreated);
      return created >= since && l.status !== 'client' && l.status !== 'perdu';
    });

    // 2. Appliquer le tag
    let updated = 0, errors = [];
    for (const lead of targeted) {
      try {
        await patchLeadTags(lead.id, [tag]);
        updated++;
      } catch (e) {
        errors.push({ id: lead.id, error: e.message });
      }
    }

    res.json({ ok: true, targeted: targeted.length, updated, errors });
  } catch (e) {
    console.error('‚ùå /api/actions/tag-rentree/simple', e.message);
    res.status(500).json({ ok: false, error: e.message });
  }
});

// --- Server start (force start)
const isMain = true;
if (isMain) {
  try {
    const server = app.listen(PORT, BIND_HOST, () => {
      console.log(`‚úÖ M.A.X. server listening on http://${BIND_HOST}:${PORT} (pid=${process.pid})`);
    });

    // Graceful shutdown
    const shutdown = (sig) => {
      console.log(`‚ö†Ô∏è  Received ${sig}, shutting down...`);
      server.close(() => {
        console.log('Server closed.');
        process.exit(0);
      });
      setTimeout(() => process.exit(1), 5000);
    };
    process.on('SIGINT', () => shutdown('SIGINT'));
    process.on('SIGTERM', () => shutdown('SIGTERM'));

    process.on('uncaughtException', (err) => {
      console.error('UncaughtException', err && err.stack ? err.stack : String(err));
      // Allow process to crash after logging
      setTimeout(() => process.exit(1), 200);
    });
    process.on('unhandledRejection', (reason) => {
      console.error('UnhandledRejection', reason);
    });
  } catch (e) {
    console.error('Failed to start server', e && e.stack ? e.stack : String(e));
    process.exit(1);
  }
}
// permet d'importer `app` ailleurs sans d√©marrer le serveur
export default app;