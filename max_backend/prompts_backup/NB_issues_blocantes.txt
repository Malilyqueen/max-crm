═══════════════════════════════════════════════════════════════════
NB: ISSUES BLOQUANTES - COMMENT LES ÉVITER
═══════════════════════════════════════════════════════════════════

Ce document répertorie les problèmes rencontrés lors du développement de M.A.X.
et les solutions à appliquer systématiquement pour les éviter.

Date de création : 2025-11-17
Dernière mise à jour : 2025-11-17

═══════════════════════════════════════════════════════════════════

ISSUE #1 - RÉPONSES VIDES APRÈS EXÉCUTION DE TOOLS
───────────────────────────────────────────────────

SYMPTÔME:
- L'utilisateur voit une bulle vide après avoir demandé une action
- M.A.X. exécute les tools mais ne répond rien
- Conversation JSON montre: "content": ""

CAUSE:
- Après l'exécution de tools, l'IA fait un second appel
- Si ce second appel retourne un texte vide, la bulle reste vide
- Aucune indication de "mission en cours" n'est affichée

SOLUTION APPLIQUÉE (chat.js lignes 1248-1339):
1. Détecter les tool_calls et créer un message de statut:
   "⚙️ **Mission en cours** : [noms conviviaux des tools]..."
2. Créer une variable `finalText` qui combine statut + réponse IA
3. Ajouter un fallback: si texte toujours vide après tools:
   finalText = "✅ Mission terminée avec succès."
4. Utiliser `finalText` au lieu de `result.text` partout

COMMENT ÉVITER:
✅ Toujours afficher un message de statut quand des tools sont exécutés
✅ Toujours vérifier que le texte final n'est pas vide avant de l'envoyer
✅ Prévoir un message de fallback pour les cas où l'IA ne répond rien
❌ NE JAMAIS laisser une réponse vide après exécution de tools

═══════════════════════════════════════════════════════════════════

ISSUE #2 - MAUVAIS CHOIX DE TOOL POUR L'IMPORT
───────────────────────────────────────────────

SYMPTÔME:
- User upload un CSV et dit "importe ces leads"
- M.A.X. appelle `update_lead_fields` au lieu de `update_leads_in_espo`
- Tous les leads échouent avec "404 - Lead introuvable"

CAUSE:
- `update_lead_fields` cherche des leads EXISTANTS (GET puis PATCH)
- Les leads n'existent pas encore, donc 404
- La description du tool `update_leads_in_espo` n'était pas assez explicite
- Pas d'instructions claires sur quel tool utiliser pour l'import CSV

SOLUTION APPLIQUÉE:
1. Amélioration description tool dans maxTools.js (lignes 38-65):
   - Mention explicite: "force_create: CRÉER de nouveaux leads depuis CSV"
   - Mots-clés déclencheurs: "importe", "crée", "ajoute ces leads"
   - Clarification mode par défaut vs force_create

2. Ajout instructions dans max_operational_rules.txt (lignes 205-212):
   ⚡ TOOL À UTILISER POUR IMPORT :
   TOUJOURS utiliser : update_leads_in_espo avec mode: 'force_create'

3. Implémentation réelle du mode force_create (chat.js lignes 279-349):
   - Avant: mode force_create faisait PATCH (mise à jour)
   - Après: mode force_create fait POST (création)

COMMENT ÉVITER:
✅ Descriptions de tools ULTRA-EXPLICITES avec exemples d'usage
✅ Mentionner les mots-clés qui doivent déclencher le tool
✅ Ajouter des instructions dans les prompts système si nécessaire
✅ Implémenter réellement ce qui est promis dans les descriptions
❌ NE JAMAIS supposer que l'IA comprendra implicitement
❌ NE JAMAIS inventer des tools qui n'existent pas
❌ NE PAS laisser des modes "fantômes" non implémentés

RÈGLE D'OR TOOLS:
─────────────────
Si tu penses avoir besoin d'un nouveau tool → STOP

1. Vérifie si un tool existant peut faire le job
2. Lis TOUTES les descriptions de tools disponibles
3. Regarde les paramètres optionnels (mode, filters, etc.)
4. Utilise TON INTELLIGENCE pour analyser les données (pas besoin de tool pour ça)
5. Si vraiment nécessaire, demande l'ajout du tool à l'humain
6. N'invente JAMAIS un tool qui n'existe pas dans maxTools.js

EXEMPLE CONCRET (ENRICHISSEMENT):
─────────────────────────────────
❌ MAUVAIS: Appeler un tool "enrich_leads_from_description" (n'existe pas)
✅ BON:
   1. query_espo_leads pour récupérer les leads
   2. ANALYSER TOI-MÊME les descriptions avec ton IA
   3. update_leads_in_espo pour mettre à jour avec les données extraites

═══════════════════════════════════════════════════════════════════

ISSUE #3 - VALIDATION DES CHAMPS ESPOCRM
─────────────────────────────────────────

SYMPTÔME:
- Import échoue avec "400 Bad Request - validation a échoué pour le champ X"
- Exemples: `source`, `phoneNumber`, `status`

CAUSE:
- EspoCRM valide strictement les champs avant insertion
- Champs ENUM n'acceptent que des valeurs prédéfinies
- Numéros de téléphone doivent être au format international
- On envoyait des valeurs custom non acceptées

EXEMPLES CONCRETS:
──────────────────
❌ source: 'Import CSV' → REJETÉ (valeur custom)
✅ source: 'Web Site' → ACCEPTÉ (valeur EspoCRM standard)

❌ phoneNumber: '145298922' → REJETÉ (format invalide)
✅ phoneNumber: '+33 1 45 29 89 22' → ACCEPTÉ (format international)

❌ status: 'imported' → REJETÉ (valeur custom)
✅ status: 'New' → ACCEPTÉ (valeur EspoCRM standard)

SOLUTION APPLIQUÉE (chat.js lignes 295-310):
1. Fonction formatPhoneNumber() pour convertir automatiquement:
   - 9 chiffres → format international +33
   - 10 chiffres avec 0 → format international +33
   - Nettoyage des espaces, tirets, parenthèses

2. Utilisation de valeurs EspoCRM standards:
   - source: 'Web Site' (au lieu de 'Import CSV')
   - status: 'New' (au lieu de valeurs custom)

COMMENT ÉVITER:
✅ Toujours utiliser les valeurs ENUM standard d'EspoCRM
✅ Formater les numéros de téléphone au format international
✅ Nettoyer/valider les données AVANT de les envoyer à l'API
✅ Si un champ est optionnel et vide, ne pas l'envoyer du tout
❌ NE JAMAIS envoyer des valeurs custom pour les champs ENUM
❌ NE PAS supposer qu'EspoCRM acceptera n'importe quel format

CHAMPS ENUM CONNUS:
───────────────────
- source: ['Web Site', 'Call', 'Email', 'Existing Customer', 'Partner', 'Public Relations', 'Direct Mail', 'Conference', 'Trade Show', 'Web Download', 'Web Search', 'Campaign', 'Other']
- status: ['New', 'Assigned', 'In Process', 'Converted', 'Recycled', 'Dead']
- Pour d'autres champs, consulter l'admin EspoCRM avant d'envoyer

═══════════════════════════════════════════════════════════════════

ISSUE #4 - LEADS EXISTANTS CONSIDÉRÉS COMME ÉCHECS
───────────────────────────────────────────────────

SYMPTÔME:
- Import de 20 leads
- 14 réussissent, 6 échouent avec "Erreur de conflit, lead déjà existant"
- M.A.X. considère cela comme un échec

CAUSE:
- Le code faisait uniquement POST (création)
- Si le lead existait déjà, erreur 409 Conflict
- Aucune tentative de mise à jour

SOLUTION APPLIQUÉE (chat.js lignes 327-366):
1. Avant chaque création, rechercher si le lead existe (par email)
2. Si existe → PUT (mise à jour) avec l'ID trouvé
3. Si n'existe pas → POST (création)
4. Considérer les deux comme succès
5. Reporter: "X créés, Y mis à jour (existaient déjà)"

COMMENT ÉVITER:
✅ Toujours implémenter la logique UPSERT (créer OU mettre à jour)
✅ Rechercher par identifiant unique (email, phone, etc.) avant création
✅ Considérer "existe déjà" comme succès partiel, pas comme échec
✅ Reporter clairement: créations vs mises à jour
❌ NE JAMAIS abandonner l'import si certains éléments existent déjà
❌ NE PAS considérer "409 Conflict" comme un échec définitif

LOGIQUE UPSERT STANDARD:
────────────────────────
try {
  // Tenter création
  await POST('/entity', data);
  results.created++;
} catch (error) {
  if (error.code === 409 || error.message.includes('already exists')) {
    // Rechercher l'entité existante
    const existing = await GET('/entity?where...');
    if (existing) {
      // Mettre à jour
      await PUT(`/entity/${existing.id}`, data);
      results.updated++;
    }
  } else {
    results.failed++;
  }
}

═══════════════════════════════════════════════════════════════════

ISSUE #5 - IMPORT BLOQUÉ PAR CHAMPS MANQUANTS
──────────────────────────────────────────────

SYMPTÔME:
- CSV uploadé avec champs vides (secteur, taille, maturité)
- M.A.X. refuse d'importer: "Il manque des champs"
- User frustré: "Mais je veux quand même les importer!"

CAUSE:
- M.A.X. validait la complétude des données AVANT import
- Bloquait si des champs "importants" étaient vides
- Oubliait la mission: importer PUIS enrichir

SOLUTION APPLIQUÉE (max_operational_rules.txt Section 8):
WORKFLOW EN 2 PHASES OBLIGATOIRE:
1. PHASE 1 - IMPORT IMMÉDIAT (avec données partielles)
   - Importer TOUS les leads du fichier
   - Utiliser uniquement les champs présents
   - Laisser les champs vides... vides

2. PHASE 2 - ENRICHISSEMENT POST-IMPORT
   - Analyser la colonne "remarque" de chaque lead
   - Utiliser l'IA pour déduire les champs manquants
   - Mettre à jour les leads avec les données enrichies

COMMENT ÉVITER:
✅ TOUJOURS importer d'abord, enrichir ensuite
✅ Ne JAMAIS bloquer l'import à cause de données manquantes
✅ Exploiter la colonne "remarque" comme source d'enrichissement
✅ Informer l'utilisateur des deux phases: import OK → enrichissement en cours
❌ NE JAMAIS dire "je ne peux pas importer car il manque X"
❌ NE PAS demander des infos supplémentaires avant d'importer
❌ NE PAS ignorer la colonne "remarque" lors de l'enrichissement

COLONNES RICHES À ANALYSER:
───────────────────────────
- remarque / description / note / commentaire
- Ces colonnes contiennent souvent:
  * Contexte métier du prospect
  * Besoins exprimés
  * Objectifs business
  * Technologies utilisées
  * Projets en cours
  * Indices de secteur, taille, maturité, urgence

═══════════════════════════════════════════════════════════════════

ISSUE #6 - INVENTION D'IDs FANTAISISTES
────────────────────────────────────────

SYMPTÔME:
- M.A.X. appelle update_lead_fields avec des IDs comme:
  * 'next_move_lead_id'
  * 'casa_bella_design_id'
  * 'alpha_drone_systems_id'
- API EspoCRM renvoie "404 - Lead introuvable" pour tous
- User voit: "16 leads échoués"

CAUSE:
- M.A.X. INVENTE des IDs basés sur les noms des entreprises
- Ne récupère PAS les vrais IDs depuis EspoCRM
- Les vrais IDs EspoCRM sont alphanumériques: '67392a1e8b4c9a5e1'
- M.A.X. essaie de mettre à jour des entités qui n'existent pas

SOLUTION OBLIGATOIRE:
1. TOUJOURS récupérer les IDs réels AVANT toute mise à jour:
   query_espo_leads({limit: 20, sortBy: "createdAt", sortOrder: "desc"})

2. Utiliser UNIQUEMENT les IDs retournés par l'API:
   [{id: '67392a1e8b4c9a5e1', name: 'NextMove Logistics'}, ...]

3. Passer ces IDs réels aux tools de mise à jour:
   update_lead_fields({
     leads: [{id: '67392a1e8b4c9a5e1'}],
     fields: {segments: ['Logistique']}
   })

COMMENT ÉVITER:
✅ TOUJOURS query_espo_leads AVANT update_lead_fields
✅ Utiliser les IDs retournés par l'API (format: chaîne alphanumérique aléatoire)
✅ Mémoriser les IDs récupérés pour les réutiliser
✅ Vérifier que l'ID ressemble à '67392a1e8b4c9a5e1', PAS à 'next_move_lead_id'
❌ JAMAIS inventer des IDs basés sur les noms
❌ JAMAIS utiliser des IDs descriptifs comme 'company_name_id'
❌ JAMAIS supposer qu'un ID existe sans l'avoir récupéré

EXEMPLE MAUVAIS:
────────────────
leads: [
  { id: 'next_move_lead_id', name: 'NextMove Logistics' },  ❌ FAUX ID
  { id: 'casa_bella_design_id', name: 'Casa Bella' }        ❌ FAUX ID
]

EXEMPLE BON:
────────────
1. query_espo_leads({limit: 20})
   → Retourne: [{id: '67392a1e8b4c9a5e1', name: 'NextMove Logistics'}, ...]

2. update_lead_fields({
     leads: [{id: '67392a1e8b4c9a5e1'}],  ✅ VRAI ID récupéré
     fields: {segments: ['Logistique']}
   })

═══════════════════════════════════════════════════════════════════

ISSUE #7 - CHAMP "SEGMENTS" MANQUANT (RÉSOLU ✅)
────────────────────────────────────────────────

SYMPTÔME (HISTORIQUE):
- L'enrichissement détectait correctement secteur + tags
- Mais affichait "0 leads mis à jour" (0/20)
- Les leads semblaient enrichis mais rien n'était sauvegardé

CAUSE RACINE:
- Le champ "segments" N'EXISTAIT PAS dans EspoCRM
- Le PATCH ignorait silencieusement le champ manquant
- Secteur était mis à jour, mais pas les tags

SOLUTION APPLIQUÉE (2025-11-17):
✅ Créé le champ "segments" (Multi-Enum)
✅ Activé allowCustomOptions: true (tags IA acceptés)
✅ Clear cache + rebuild EspoCRM
✅ Tests validés avec tags prédéfinis ET custom

RÉSULTAT:
✅ L'enrichissement fonctionne maintenant à 100%
✅ Secteur + Tags + Description sont bien sauvegardés
✅ L'IA peut utiliser n'importe quels tags détectés

FICHIERS MODIFIÉS:
- lib/emailAnalyzer.js (ligne 348)
- routes/chat.js (ligne 720)

DOCUMENTATION:
- Voir ENRICHMENT_FIX_REPORT.md pour détails complets

═══════════════════════════════════════════════════════════════════

RÉSUMÉ - LES 7 RÈGLES D'OR
───────────────────────────

1. ✅ TOUJOURS INFORMER L'UTILISATEUR
   → Afficher "⚙️ Mission en cours" pendant les actions
   → Ne jamais laisser une bulle vide
   → Prévoir un fallback si l'IA ne répond rien

2. ✅ UTILISER LES BONS TOOLS
   → Lire TOUTES les descriptions avant de choisir
   → Ne JAMAIS inventer un tool qui n'existe pas
   → Vérifier les modes/paramètres optionnels disponibles

3. ✅ VALIDER LES DONNÉES ESPOCRM
   → Utiliser uniquement les valeurs ENUM standards
   → Formater les téléphones au format international
   → Nettoyer les données avant envoi

4. ✅ IMPLÉMENTER UPSERT PARTOUT
   → Toujours gérer "existe déjà" comme succès partiel
   → Rechercher puis mettre à jour si existe
   → Reporter: créations + mises à jour

5. ✅ IMPORTER PUIS ENRICHIR
   → Ne JAMAIS bloquer l'import pour données manquantes
   → Phase 1: import avec données partielles
   → Phase 2: enrichissement via analyse IA

6. ✅ RÉCUPÉRER LES IDs RÉELS
   → TOUJOURS query_espo_leads AVANT update_lead_fields
   → Ne JAMAIS inventer d'IDs ('next_move_lead_id' est INTERDIT)
   → Utiliser UNIQUEMENT les IDs retournés par l'API ('67392a1e8b4c9a5e1')
   → Mémoriser les IDs récupérés pour les réutiliser

7. ✅ VÉRIFIER L'EXISTENCE DES CHAMPS (NOUVEAU)
   → Le champ "segments" a été créé pour l'enrichissement IA
   → Accepte des valeurs personnalisées (allowCustomOptions: true)
   → L'IA peut utiliser n'importe quels tags détectés
   → En cas de doute, consulter ENRICHMENT_FIX_REPORT.md

═══════════════════════════════════════════════════════════════════

CHECKLIST AVANT CHAQUE ACTION
──────────────────────────────

Avant d'exécuter une action, M.A.X. doit se poser ces questions:

□ Est-ce que j'affiche un message de statut à l'utilisateur?
□ Est-ce que j'utilise le bon tool pour cette tâche?
□ Est-ce que mes données respectent les validations EspoCRM?
□ Est-ce que je gère le cas "existe déjà" intelligemment?
□ Est-ce que je bloque à tort à cause de données manquantes?
□ Est-ce que ma réponse finale sera visible par l'utilisateur?

Si OUI aux 6 questions → Procéder
Si NON à une question → Corriger avant d'agir

═══════════════════════════════════════════════════════════════════

FIN DU DOCUMENT NB: ISSUES BLOQUANTES
